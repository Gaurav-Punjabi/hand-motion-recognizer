
import com.sun.demo.jvmti.hprof.Tracker;
import java.awt.AWTException;
import java.awt.Robot;
import java.util.ArrayList;
import java.util.List;
import javax.swing.ImageIcon;
import org.opencv.core.Core;
import org.opencv.core.CvType;
import org.opencv.core.Mat;
import org.opencv.core.MatOfPoint;
import org.opencv.core.Point;
import org.opencv.core.Scalar;
import org.opencv.core.Size;
import org.opencv.imgproc.Imgproc;
import org.opencv.objdetect.CascadeClassifier;
import org.opencv.videoio.VideoCapture;
import org.opencv.videoio.Videoio;

/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

/**
 *
 * @author Gaurav-Punjabi
 */
public class MainFrame extends javax.swing.JFrame implements ColorConstants {
    
    private Robot robot;
    private Tracker tracker;
    /**
     * Creates new form MainFrame
     */
    public MainFrame() {
        initComponents();
        customInit();
        try {
            this.robot = new Robot();
        } catch(AWTException awte) {
            System.out.println("awte.getMessage() = " + awte.getMessage());
        }
    }
    private void video() {
        VideoCapture capture = new VideoCapture(0);
        CascadeClassifier cascadeClassifier = new CascadeClassifier("");
        Mat webcamMatImage = new Mat();
        Mat inRange = new Mat();
        Mat hsvImage = new Mat();
        Mat filterImage = new Mat();
        
        capture.set(Videoio.CAP_PROP_FRAME_WIDTH,800);
		capture.set(Videoio.CAP_PROP_FRAME_HEIGHT,600);

        Mat mat = new Mat(3,3,CvType.CV_8U,new Scalar(1,1,1));
        
		if( capture.isOpened()) {  
			while (true){  
				capture.read(webcamMatImage);
				if( !webcamMatImage.empty() ){
//                    Imgproc.cvtColor(webcamMatImage, hsvImage, Imgproc.COLOR_BGR2HSV);
//                    Core.inRange(hsvImage,new Scalar(0,0,0), new Scalar(20, 255, 255), inRange);
//                    Mat kernel = Imgproc.getStructuringElement(Imgproc.MORPH_ELLIPSE, new Size(5,5),new Point(4,4));
//                    Imgproc.dilate(inRange, inRange, kernel);
//                    List<MatOfPoint> contours = new ArrayList<>();
//                    Imgproc.findContours(inRange, contours, new Mat(), Imgproc.RETR_EXTERNAL, Imgproc.CHAIN_APPROX_SIMPLE);
//                    MatOfPoint largestContour = contours.get(0);
//                    int indexOfLargest = 0,i = 0;
//                    for(MatOfPoint contour : contours) {
//                        if(Imgproc.contourArea(contour) > Imgproc.contourArea(largestContour)) {
//                            largestContour = contour;
//                            indexOfLargest = i;
//                        }
//                        i++;
//                    }
//                    Imgproc.drawContours(webcamMatImage, contours, indexOfLargest, new Scalar(0,255,0));
//                    Point point = largestContour.toArray()[2];
//                    robot.mouseMove((int)point.x,(int)point.y);
                    Imgproc.cvtColor(webcamMatImage, webcamMatImage, Imgproc.COLOR_BGR2GRAY);
                    MatOfRect faces = new MatOfRect();
                    cascadeClassifier.detectMultiScale(webcamMatImage, faces, 1.1, 2, 0, new Size(250,), maxSize);
                    jlIcon.setIcon(new ImageIcon(ImageProcessor.toBufferedImage(webcamMatImage)));
				}  
				else{  
					System.out.println(" -- Frame not captured -- Break!"); 
					break;  
				}
			}  
		}
		else{
			System.out.println("Couldn't open capture.");
		}
    }
    private Mat show(Mat dest, Mat mat, Scalar color) {
        Mat result = mat.clone();
        List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
        Mat contourMat = mat.clone();
        Imgproc.findContours(contourMat,contours,new Mat(),Imgproc.RETR_EXTERNAL,Imgproc.CHAIN_APPROX_NONE);
        Imgproc.drawContours(dest, contours, -1, color,5);
        return dest;
    }
    private void customInit() {
        System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
        new Thread() {
            @Override
            public void run() {
                video();
            }
        }.start();
    }
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jlDisplay = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jlIcon = new javax.swing.JLabel();
        jtfH1 = new javax.swing.JTextField();
        jtfS1 = new javax.swing.JTextField();
        jtfV1 = new javax.swing.JTextField();
        jtfH2 = new javax.swing.JTextField();
        jtfS2 = new javax.swing.JTextField();
        jtfV2 = new javax.swing.JTextField();
        jcbHsv = new javax.swing.JCheckBox();

        jlDisplay.setBackground(new java.awt.Color(255, 255, 255));
        jlDisplay.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jlDisplayMouseClicked(evt);
            }
        });

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jScrollPane1.setViewportView(jlIcon);

        jtfH1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jtfH1ActionPerformed(evt);
            }
        });

        jtfS1.setColumns(7);

        jtfV1.setColumns(7);

        jtfH2.setColumns(7);

        jtfS2.setColumns(7);

        jtfV2.setColumns(7);

        jcbHsv.setText("HSV");
        jcbHsv.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jcbHsvActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jtfH1, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jtfS1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jtfV1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jtfH2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jtfS2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jtfV2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(jcbHsv)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addGap(0, 10, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jtfH1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jtfS1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jtfV1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jtfH2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jtfS2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jtfV2, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jcbHsv))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 547, javax.swing.GroupLayout.PREFERRED_SIZE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jlDisplayMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jlDisplayMouseClicked
        int x = evt.getX();
        int y = evt.getY();
        byte[] color = new byte[3];
        hsv.get(x,y,color);
        for(byte b : color)
            System.out.println("Pixel value : " + ((int)b & 0xFF));
    }//GEN-LAST:event_jlDisplayMouseClicked

    private void jtfH1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jtfH1ActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jtfH1ActionPerformed

    private void jcbHsvActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jcbHsvActionPerformed
        this.isHsv = !this.isHsv;
    }//GEN-LAST:event_jcbHsvActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
//                System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
//                Mat mat = new Mat(3,3,CvType.CV_8UC3,new Scalar(125,0,255));
//                byte[] buffer = new byte[3*3];
//                mat.get(0,0,buffer);
//                for(byte b : buffer) {
//                    System.out.print(b + " ");
//                }
                new MainFrame().setVisible(true);
            }
        });
    }
    private Mat hsv;
    private boolean isHsv = true;
    private GestureRecognizer ref;
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JCheckBox jcbHsv;
    private javax.swing.JLabel jlDisplay;
    private javax.swing.JLabel jlIcon;
    private javax.swing.JTextField jtfH1;
    private javax.swing.JTextField jtfH2;
    private javax.swing.JTextField jtfS1;
    private javax.swing.JTextField jtfS2;
    private javax.swing.JTextField jtfV1;
    private javax.swing.JTextField jtfV2;
    // End of variables declaration//GEN-END:variables
}
